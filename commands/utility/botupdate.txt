const { 
    SlashCommandBuilder, 
    EmbedBuilder, 
    ActionRowBuilder, 
    ButtonBuilder, 
    ButtonStyle 
} = require("discord.js");

const fs = require("fs");
const path = require("path");
require("dotenv").config();

const UPDATES_FILE = path.join(__dirname, "../../data/updates.json");

module.exports = {
    data: new SlashCommandBuilder()
        .setName("botupdatee")
        .setDescription("Show all bot updates with pagination."),

    async execute(interaction) {
        await interaction.deferReply();

        const token = process.env.GH_TOKEN;
        const owner = process.env.GH_OWNER;
        const repo = process.env.GH_REPO;

        if (!token || !owner || !repo) {
            return interaction.editReply("GitHub configuration missing (GH_TOKEN, GH_OWNER, GH_REPO).");
        }

        // Fetch commits
        const url = `https://api.github.com/repos/${owner}/${repo}/commits`;

        let commits;
        try {
            const res = await fetch(url, {
                headers: { Authorization: `token ${token}` }
            });

            if (!res.ok) throw new Error("GitHub API error");
            commits = await res.json();
        } catch (e) {
            console.error(e);
            return interaction.editReply("Failed to fetch commits from GitHub.");
        }

        // Parse commits → updates
        let updates = commits.map((c, i) => ({
            version: `v${commits.length - i}`,
            title: c.commit.message.split("\n")[0],
            category: detectCategory(c.commit.message),
            date: new Date(c.commit.author.date).toLocaleString(),
            url: c.html_url
        }));

        // Save JSON
        fs.writeFileSync(UPDATES_FILE, JSON.stringify(updates, null, 2));

        // Pagination
        let page = 0;
        const perPage = 5;
        const totalPages = Math.ceil(updates.length / perPage);

        const render = (p) => {
            const start = p * perPage;
            const pageItems = updates.slice(start, start + perPage);

            const embed = new EmbedBuilder()
                .setTitle("Bot Update History")
                .setColor("#0099ff")
                .setFooter({ text: `Page ${p + 1} of ${totalPages}` })
                .setTimestamp();

            pageItems.forEach(up => {
                embed.addFields({
                    name: `${up.version} • ${up.category}: ${up.title}`,
                    value: `Date: ${up.date}\n${up.url}`
                });
            });

            const row = new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                    .setCustomId("first")
                    .setLabel("First")
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(p === 0),

                new ButtonBuilder()
                    .setCustomId("prev")
                    .setLabel("Previous")
                    .setStyle(ButtonStyle.Secondary)
                    .setDisabled(p === 0),

                new ButtonBuilder()
                    .setCustomId("next")
                    .setLabel("Next")
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(p === totalPages - 1),

                new ButtonBuilder()
                    .setCustomId("last")
                    .setLabel("Last")
                    .setStyle(ButtonStyle.Primary)
                    .setDisabled(p === totalPages - 1)
            );

            return { embed, row };
        };

        // Send first page
        let first = render(page);

        const msg = await interaction.editReply({
            embeds: [first.embed],
            components: [first.row]
        });

        const collector = msg.createMessageComponentCollector({ time: 5 * 60 * 1000 });

        collector.on("collect", async (btn) => {
            if (btn.user.id !== interaction.user.id)
                return btn.reply({ content: "This button is not for you.", ephemeral: true });

            if (btn.customId === "next") page++;
            if (btn.customId === "prev") page--;
            if (btn.customId === "first") page = 0;
            if (btn.customId === "last") page = totalPages - 1;

            const next = render(page);

            await btn.update({
                embeds: [next.embed],
                components: [next.row]
            });
        });

        collector.on("end", () => {
            msg.edit({ components: [] }).catch(() => {});
        });
    }
};

// Auto detect category
function detectCategory(msg) {
    msg = msg.toLowerCase();

    if (msg.includes("add") || msg.includes("new")) return "Added";
    if (msg.includes("fix")) return "Fixed";
    if (msg.includes("update") || msg.includes("improve")) return "Updated";
    if (msg.includes("remove") || msg.includes("delete")) return "Removed";

    return "Change";
}
